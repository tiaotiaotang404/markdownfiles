### 一.关于指令集架构：

##### RSCV指令集中非特权子集：

![image-20230531095742731](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230531095742731.png)

##### 拓展的指令集：

![image-20230531095840674](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230531095840674.png)

### 二，关于微体系结构

1. 内存层级方面：此项目不需要，直接从内存访问指令、数据
2. 指令集并行方面：此项目不需要，项目实现的是单周期CPU，没有流水线，没有多发射
3. 数据级并行方面：此项目不需要，不用支持向量拓展
4. 线程级并行方面：此项目为单核CPU，不需要
5. 综上，此项目只是一个简单的单周期RV32I处理器

### 三，初步设计

#### RV32I指令集分析：

##### 指令格式如下：

![image-20230531100851029](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230531100851029.png)

1. **R类型即寄存器（Register）类型**，有三个操作数，两个源操作数均来自寄存器（rs1和rs2），目的操作数为寄存器（rd）；
2. **I类型即立即数（Immediate）类型**，有三个操作数，两个源操作数分别来自立即数（imm）和寄存器（rs1），目的操作数为寄存器（rd）；
3. **S类型即存储（Store）类型**，有三个操作数，均为源操作数，其中寄存器rs1和立即数imm运算得到存储的地址，rs2寄存器的值为被存储的数；
4. **B类型即分支（Branch）类型**，有三个操作数，均为源操作数，其中两个寄存器（rs1和rs2）的值用于比较，立即数imm的值为分支目的地址的偏移量；
5. **U类型即无符号立即数（Unsigned immediate）类型**，有两个操作数，立即数imm为源操作数，rd为目的操作数，此指令用于将立即数加载到指定寄存器rd；
6. **J类型即跳转（Jump）类型**，有两个操作数，立即数imm为源操作数，用于计算跳转目的地址，rd为目的操作数，用于记录跳转前指令的下一条指令的地址；

##### RV32I指令如下：共计四十条

![image-20230531101314729](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230531101314729.png)

根据指令功能进行分类：

1. 直接跳转类：JAL、JALR

​		需要对PC寄存器的值进行直接修改，同时写一个寄存器；

2. 条件分支类：BEQ、BNE、BLT、BGE、BLTU、BGEU

​		首先需要进行比较，然后根据比较结果选择是否修改PC寄存器；

3. 加载或存储类：LB、LH、LW、LBU、LHU、SB、SH、SW

​		需要访问数据存储，加载只读取数据，存储只写入数据；

4. 算数逻辑运算和位运算类：包括所有加法、减法，按位与、或、异或，逻辑左移、逻辑右移、算术右移相关指令；

​		对操作数进行运算，然后将结果写入目的寄存器；

5. 比较指令类：SLTI、SLTIU、SLT、SLTU

​		类似算数逻辑与位运算

6. 其他指令类：FENCE、ECALL、EBREAK

#### 数据通路和控制逻辑的初步设计

CPU需要包含以下组件：

1. 指令内存（`MemInst`）：接收一个32位的指令地址，读出指令
2. PC寄存器（`PCReg`）：为指令内存提供指令地址，每个时钟周期地址+4，当前指令为跳转时，下一条指令为跳转目的地址，当前指令为分支指令且分支成功时，下一条指令为分支目标地址
3. 通用寄存器堆（`Registers`）：可读可写的寄存器，接收寄存器号，为运算单元提供操作数，接收运算结果或从数据内存读取到的值
4. 指令译码器（`Decoder`）：对指令进行译码，解析得到立即数、操作码、寄存器号等信息
5. 运算单元（`ALU`）：根据操作数和操作码进行运算，运算结果写到寄存器，分支指令时将比较结果发送给PC，加载存储指令时计算地址
6. 数据内存（`MemData`）：根据加载/存储地址，加载或存储数据，加载或存储依赖于译码器的译码；
7. 控制单元（`Controller`）：根据译码结果，给出对数据通路进行控制的相关信号；

以上组件描述的是数据通路。

控制逻辑需要根据译码结果对数据通路进行控制，可能需要以下几个方面：

1. `ctrlJump`：指令是否为跳转指令？如果是，需要给控制信号到PC，要求在下一时钟周期修改为跳转目的地址；
2. `ctrlBranch`：指令是否为分支指令？如果是，根据运算单元的比较结果（分支与否），决定是否让PC在下一个时钟周期跳转的分支目标地址；
3. `ctrlRegWrite`：指令是否需要写寄存器？如果是，将运算单元的结果或从数据内存中读取的值写入寄存器；
4. `ctrlLoad`：指令是否为加载指令？如果是，写入寄存器的值来源应该是数据内存；
5. `ctrlStore`：指令是否为存储指令？如果是，将寄存器中的值写入数据内存；
6. `ctrlALUSrc`：指令的操作数2是立即数还是寄存器值？根据此选择操作数2的值；
7. `ctrlJAL`：指令是否为JAL指令？如果是，操作数1的值应当为PC寄存器的值；
8. `ctrlOP`：为ALU指定具体的操作，加？减？或者其他啥？

#### CPU框架图：

![image-20230531103832724](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230531103832724.png)

### 四，具体实现

##### 全局配置模块：用于配置项目中用到的变量，便于项目的修改扩展

##### PC寄存器的实现：

功能如下：

1. 32位的指令地址输出，为指令内存提供地址以获取指令
2. 每个时钟周期更新+4
3. 若当前指令为跳转指令，会接收控制单元的信号`ctrlJump`，接收计算得到的跳转地址
4. 若当前指令为分支指令，会接收控制单元的信号`ctrlBranch`和运算单元的分支结果，分支成功就将结果作为下一个跳转地址
5. 寄存器初始化时，输出指令地址为0

