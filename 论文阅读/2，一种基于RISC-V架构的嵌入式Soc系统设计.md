## 一种基于RISC-V架构的嵌入式Soc系统设计

### 1 绪论

### 2 RISC-V处理器架构

#### 2.1 RISC-V指令集

#### 2.2 流水线冒险

​		冒险共分为三类：结构冒险、数据冒险、控制冒险

1. **结构冒险**：由于**硬件资源之间的竞争**，使得流水线操作无法同时进行。例如，在冯诺依曼架构中由于访问存储器时所使用的是共享资源，而在流水线运行过程中取指阶段和存储阶段都需要对存储器进行访问，导致后者的访问需要等待前者结束才可以进行，会产生结构冒险。

​		**如果硬件资源足够多并且内存访问总线是独立分开的，就可以避免**。可以将取指操作和存储数据操作所用的存储器单独分开设置，**这种从物理结构上将指令和数据访问内存以及他们的访问通道分开的结构称为哈佛结构**。

2. **数据冒险**：由于**相邻指令之间存在依赖关系**，当前指令需要用到前面指令的运行结果，前面指令还未结束时，会导致当前指令无法立即获取正确的数据。

​		**可以采用数据直通的方式避免**。例如，指令运行到写回阶段结束，但实际早在执行阶段就已得到运算结果，因此**数据直通是指将出在执行阶段的结果直接传递给下一条指令**。

​		当处理器执行load指令时使用数据直通会存在意外，因为load指令只有在存储阶段结束进入写回阶段时，读取的数据才最终确定，而下一条指令已经开始进入存储阶段，这显然与数据直通运算机制不符，这种称之为**load冒险**。这类冒险从根本上不可避免，在实际情况中，可以将依赖指令保持，并在冒险阶段当作nop指令处理。

3. **控制冒险**：**无法确定下一条指令的位置而产生的冒险问题**。在流水线**执行跳转指令时**，由于当前指令的判断条件还未计算出，导致下一条指令无法正常运行，进而产生控制冒险。

​		针对跳转指令，理论上只能在执行阶段完成之后才能分析出最终的跳转结果，会很影响处理器的性能。通常采用**分支预测**的方式解决。

​		分支预测一般有静态预测和动态预测。

> [计算机体系结构学习（5）——分支预测 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/561643046)
>
> [(29条消息) CPU设计-分支预测_cpu分支预测_俩个圆的博客-CSDN博客](https://blog.csdn.net/yueqiu693/article/details/125828968)

#### 2.3 总线协议概述

##### 2.3.1 AHB-Lite总线协议

##### 2.3.2 APB总线协议

### 3 RISC-V SoC处理器设计

​		文章设计的处理器为六级流水线，分为取指1（IF1）、取指2（IF2）、译码（ID）、执行（EX）、存储（MEM）以及写回（WB），在此架构基础上对所有指令进行时钟节拍分析，进而确定各模块之间的数据交互并最终完成处理器的整体结构设计。

#### 3.1 设计要求

1. 处理器采用哈佛结构，指令存储器和数据存储器分别独立实现
2. 六级流水线设计，指令顺序执行，单发射且支持静态分支预测
3. 最大可支持RV32IMCZicsr指令集架构
4. 自带硬件乘除法
5. 带有PLIC和CLINT中断控制器
6. 丰富的外设，基于APB总线的GPIO、USART、SPI、PWM等
7. 采用RISC-V交叉编译工具riscv32-gnu-toolchain及C代码进行验证
8. 能够在FPGA器件上运行
9. 尽可能使用不带异步复位的D触发器，以减少处理器面积；外设IP中多采用门控时钟的设计方式以降低SoC系统的整体功耗

#### 3.2 总体结构设计

​		总体结构如图所示

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230704111124100.png" alt="image-20230704111124100" style="zoom:50%;" />

​		处理器内核采用六级流水线架构，总线互联采用AMBA总线协议中的AHB-Lite总线和APB总线，基本外设包括1个带有32端口的GPIO模块、3个USART模块、2个SPI模块、1个PWM模块及1个内部看门狗IWDG模块。

#### 3.3 六级流水线架构分析

![image-20230704111559090](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230704111559090.png)

​		IF1以及IF2阶段共同构成取指阶段使得取指需要两级流水完成，其中IF1阶段包含PC计数器的自增以及对分支的预测；IF2阶段通过相关的操作（如无条件跳转的运算以及条件跳转指令的刷新等）产生最终的指令码地址。ID阶段对所有指令进行译码的同时根据直通标志信号选择正确的源寄存器数据。EX阶段对所有的指令进行运算，同时包含硬件乘除法模块以便加快流水线的处理速度。MEM阶段在普通指令中只起到过渡作用，而对于load和store指令将产生内部存储器或外设的读写地址以及读写数据信号。WB阶段为写回阶段，其中一部分隐藏在ID阶段中，与此同时考虑到字节以及半字操作还需要一个简单的数据截取运算模块。

#### 3.4 RISC-V指令节拍分析

​		首先对每一条指令进行时钟节拍分析（每一级流水线对应一个时钟节拍），通过节拍分析确定各模块的信号及连接关系，最后进行功能模块划分并设计。

​		**时钟节拍分析实际上就是对每一个时钟节拍上所进行的动作进行分析，使用节拍分析有利于观察数据流的走向，而在时钟节拍分析中通常以灰色实线圆表示时序逻辑，白色虚线圆表示组合逻辑，在圆的两侧表示相关信号的输入与输出。**

> 理解：对指令进行时钟节拍分析就是对每条指令的具体行为进行分析，观察经过每一级流水线后的数据流的走向，确定每条指令与各个模块之间的联系，便于进行后续模块的划分与设计以及指令的优化。

##### 3.4.1 RV32I指令集节拍分析

##### 3.4.2 RV32M指令集节拍分析

##### 3.4.3 Zicsr指令集节拍分析

#### 3.5 模块设计

​		按照数据流与控制流分开的原则将处理器内核划分为取指、译码、执行、存储、回写以及控制模块。其中取指模块需要两拍完成，分别实现取指和预测功能；译码模块除完成全部指令的译码之外，还需根据刷新或冒险等操作将多余的指令译码成nop指令；执行模块完成指令的运算并增加乘除法硬件单元以加快流水线的运行速度；存储模块在load和store指令时输出地址和数据信号以匹配AHB Master，或者在普通指令时只做数据传输使用；回写阶段一部分隐藏在译码模块中的GPR寄存器和CSR寄存器中，一部分根据funct3的值完成对数据的拼接，以上模块构成整个微架构的数据流。控制器模块根据opcode的值产生相应的寄存器读、写或直通写使能信号以构成整个微架构的控制流。

##### 3.5.1 取指模块设计

​		根据指令节拍分析，取指阶段（IF）需要两拍完成，一方面需要取指且flash的输出延时较大，另一方面需要对指令进行预测。

![image-20230705191708022](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230705191708022.png)

（1）pc_reg：主要作用产生下一条指令的地址，同时程序运行时需要复位入口地址，将此模块设计为带异步复位端的时序逻辑。

​		其中PC的变化不一定是以4字节为单位自增，由于RV32C指令集的存在，导致PC有时会以2字节自增。

（2）bdecoder：此模块与ID阶段的decoder模块复用。

（3）balu：主要功能包括根据各种延迟信号保持输出地址不变、静态分支预测以及计算无条件跳转的目标地址。

​		由于RV32C的存在，会有地址对齐的问题产生。

（4）instr_joint：此模块为RV32C独有RV32C的指令长度为16bit，而系统设计中取指恒为32bit，故需要对指令进行拼接或取地址保持。要具体根据是否为压缩指令、是否为条件跳转、是否为无条件跳转等多种情况具体分析。

（5）if_id_reg：流水线寄存器模块，只做数据传输而不做运算。

​		**在CMOS工艺库中，不带复位端的D触发器具有更小的面积以及更好的时序性能**，为了降低处理器的面积，因而此模块采用不带复位端的D触发器堆。

##### 3.5.2 译码模块设计

​		根据指令的节拍分析，译码模块除需要完成对所有指令的译码工作外，还要对GPR、CSR寄存器进行读写操作，其中读寄存器操作是在ID阶段完成，而写寄存器数据则在WB阶段完成。

![image-20230705194538795](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230705194538795.png)

（1）decoder：将指令译码，通过截取instr的相应位进行指令译码操作，当流水线刷新信号或者各种指令保持标志信号有效时，将指令解码为nop指令，对立即数的译码进行符号扩展即可。

（2）gpr：通用寄存器堆模块，除了R型指令需同时读取两次GPR之外，跳转指令在预测阶段也需要读取GPR，故可将此模块看作三口的RAM。GPR写根据地址写入数据，其中x0不可写，而GPR读取时要考虑来自EX阶段、MEM阶段、WB阶段的直通数据。

（3）csr：也是寄存器堆模块，其中写为时序逻辑，读为组合逻辑。

​		此模块中包含众多的控制和状态寄存器CSR，并且CSR寄存器的操作是原子的，操作顺序不会被打乱，故CSR寄存器不会出现数据冒险的情况。、

（4）id_ex_reg：流水线寄存器，只进行数据的传输。

##### 3.5.3 执行模块设计

![image-20230705195801392](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230705195801392.png)

（1）alu：是整个架构的计算中心，根据opcode、fun3、fun7计算相应的数据。考虑到性能和低延迟，设计在此模块中使用了超前进位加法器和乘除法器。

（2）ex_mam_reg：流水线寄存器，只做数据传输。

（3）加法器：32位的对数超前进位加法器。

> [(29条消息) 超前进位加法器（较为详细讲解）_UESTC_ICER的博客-CSDN博客](https://blog.csdn.net/qq_26707507/article/details/106146619)

（4）32位乘法器设计：booth乘法器

> [(29条消息) booth乘法器_sanworldwar的博客-CSDN博客](https://blog.csdn.net/qq_40502147/article/details/131111082)
>
> [booth乘法器的原理与verilog实现 (yii666.com)](https://www.yii666.com/blog/351897.html?action=onAll)

> 理解：乘法器最重要的三个部分为产生部分积、累加部分积以及最终相加，而booth乘法器核心思想通过编码减少乘数中1的个数，即可以减少部分积的个数，从而加快乘法运算的速度。

（5）除法器：补码整数的不恢复余数除法。

> [(29条消息) 考研计组 | 原码（不）恢复余数除法、补码不恢复余数除法_卫龙女孩的博客-CSDN博客](https://blog.csdn.net/cat_xing/article/details/100939830)

##### 3.5.4 存储模块设计

​		MEM阶段主要是产生相应的读写内存地址和数据信号，通常需要总线来访问。

##### 3.5.5 回写模块设计

​		WB阶段通常来说是隐藏的，写通用寄存器GPR时隐藏在ID阶段的gpr模块中，写控制和状态寄存器CSR时隐藏在ID阶段的csr模块中，读写内存时隐藏在总线控制器中。

##### 3.5.6 控制模块设计

​		功能是产生GPR或CSR寄存器的读写控制信号。

#### 3.6 内核顶层架构

![image-20230705202552880](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230705202552880.png)

#### 3.7~3.9 总线和中断

#### 3.10 处理器的集成

![image-20230705202807893](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230705202807893.png)

### 4 RISC-V SoC外设设计与实现

#### 4.1 APB桥

##### 4.1.1 APB桥顶层架构设计

​		APB总线挂载低速IP，AHB总线挂载高速IP。AHB Master一般为CPU，要使低速总线挂载在CPU上，必须将AHB总线转换为APB总线，这个转换模块就是APB桥。

> 理解：由于CPU和外设的工作频率不同，故通过APB桥进行频率的适配

​		APB桥作为AHB总线的Slave，同时作为低速IP的Master。

![image-20230705203649249](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230705203649249.png)

##### 4.1.2 APB桥功能设计

​		AHB总线为流水线型总线；而APB总线为低速非流水线型总线，其读写需要两拍才可完成。因此需要将AHB总线信号进行缓存，同时需要拉低HREADY信号以使总线流水暂停，这样才能使流水线型总线过渡到非流水线型总线上。

#### 4.2 GPIO

​		是芯片与外接设备进行数据交互的模块，GPIO挂载在SoC的APB总线上，通过外接接口将数据发送到总线上，或者将总线上的数据传送到外设模块，进行I/O数据通信和控制。

#### 4.3 USART

##### 4.3.1 USART顶层架构设计

​		USART通用同步异步收发器，使SoC可以与外部设备通过不归零编码的形式实现**全双工同步异步串行数据通信**。

![image-20230705210330544](C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230705210330544.png)

​		其中APB转寄存器模块（apb2reg）可以与其他外设共用，同时可以方便的将整体代码移植到其他总线架构上；寄存器控制模块（usart_regctrl）；usart功能模块（usart）。

##### 4.3.2 USART功能设计

​		包含波特率发生器模块、usart发送器模块、usart接收器模块以及同步模块四部分。

#### 4.4 SPI

​		SPI串行外围接口是一种高速、全双工、同步的通讯总线，可使用SPI接口与外设之间进行通讯。

#### 4.5 增强型PWM

#### 4.6 IWDG内部看门狗

### 5 RISC-V SoC验证与结果分析

​		通过三种方式对整个系统进行验证：

1. 编写定量指令码验证内核的功能，包括各类指令的逻辑功能、数据冒险以及分支跳转和流水线刷新等。

​		只能确保内核运行的主体功能，异常处理功能极少能验证充分。

2. 编写功能性C代码，利用RISC-V的交叉编译工具编译成hex文件，然后利用Python语言，编写脚本将hex文件转换成指令码，对其功能性进行验证。

​		此方法非常符合实际的行为，即利用编译器生成的指令码进行验证，但验证手段较复杂，不适合一开始系统不稳定时的验证。

3. 将设计的全部RTL代码下板，进行板级验证。

​		此方法可以发现隐藏的时序问题。

​		除此之外，使用DC综合工具将处理器的设计代码进行综合，以验证时序、面积、功耗的设计要求。

#### 5.1 指令码定量验证

​		直接运行指令码，通过观察结果的时序图判断功能是否正确，判断流水线的级数是否正确等。

#### 5.2 C代码验证

​		利用RISC-V交叉编译工具riscv-gnu-toolchain将编写的功能性测试C代码生成RISC-V处理器可识别的指令码，利用生成的指令码做功能性的验证，如LED点亮，各个外设的功能驱动使用等。

#### 5.3 FPGA原型验证

#### 5.4 DC综合

​		综合就是把行为级的RTL代码在工艺、面积、时序等约束条件下转换成对应的门级网表。

​		综合主要包括三个阶段：转换、优化和映射。
