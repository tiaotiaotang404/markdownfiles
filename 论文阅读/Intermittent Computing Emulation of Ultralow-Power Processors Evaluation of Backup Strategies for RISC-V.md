## Intermittent Computing Emulation of Ultralow-Power Processors: Evaluation of Backup Strategies for RISC-V

## 超低功耗处理器的间歇计算仿真：RISC-V备份策略的评估

**摘要：随着能量采集电路的进步以及处理、传感和通信硬件的功率需求的降低，我们有可能将物联网设备从电池中解放出来。然而，由于来自环境的不规则电源可用性，移除电池会导致频繁的电源故障。这种情况导致设备在瞬态环境功率下间歇性地进行计算。间歇计算需要对现有处理器设计进行重大的微体系结构修改，以确保在电源故障的情况下自动进行计算。例如，内置的非易失性存储器组件应该集成在处理器架构中。因此，需要实施不同的微体系结构自动备份策略。在这项工作中，我们介绍了基于中断的软件方法的不同处理器状态备份策略，这些策略不需要修改现有处理器的微体系结构。因此，我们提出了一种系统的方法来模拟不同的处理器架构，在瞬态功率下采用不同的备份策略。为了证明我们的说法，我们制造了Ibex RISC-V核心，这是一种流行的超低功耗处理器架构，适用于间歇性计算。这是首次尝试使各种现有和未来的超低功耗处理器架构易于用于瞬时供电的计算系统。**

**索引术语：无电池物联网（IoT）设备，RISC-V，瞬态处理。**

### 1，引言

​		物联网（IoT）形成了一个设备网络，这些设备可以通过传感器感知环境，执行计算，并通过无线通信相互交互。物联网应用（例如，智能家居和城市、自动驾驶汽车和可穿戴设备）支持我们日常生活中的各种任务，以提高我们的舒适度和效率。大多数物联网设备跨越小型和电池供电的计算平台[1]。非功能特性，如功耗和可持续性，成为未来物联网应用面前的一个关键挑战[2]，[3]。由于能量采集电路的进步以及处理、传感和通信硬件功率需求的降低，我们有可能将物联网设备从电池中解放出来[4]。然而，由于环境中不规则的电源可用性，移除电池会导致频繁的电源故障，而当能量存储量不是问题时，则不会出现这种情况[5]。

​		在电源故障时，无电池设备仅在收集到的能量进入其微小储能器（例如电容器）的情况下才开始再次运行。因此，软件的执行与无电池设备关闭期间的能量收集间隔交错[6]。

​		今天的无电池平台由超低功耗微控制器组成，例如MSP430FR5969[7]，其主要架构组件（如寄存器和主存储器）是易失性的。这些微控制器包括非易失性（NV）二次存储器组件，例如铁电RAM（FRAM）[8]，用于存储在电源故障时将持续存在的信息。为了减轻不可预测的电源故障的影响，并在保持内存一致性的同时推进计算，已经提出了几种软件辅助解决方案[9]，[10]。一般来说，这些解决方案将处理器的易失性状态备份到NV存储器中，以便在重新启动时从其剩余位置恢复计算。此外，它们确保了内存的一致性，因此NV内存中的备份状态不会与易失性状态不同，反之亦然。

​		无电池平台还可以包括NV处理器（NVP），在其微体系结构中集成了内置NV存储器组件。得益于这些内置的NV逻辑组件，NVP在发生电源故障时自动将处理器状态备份到内部存储器元件，并在电源可用时恢复状态[11]。这种类型的执行使备份操作对程序员来说是透明的。由于与软件辅助解决方案相比，备份和保留操作很快（例如，大约几微秒[12]，[13]），NVP通过允许系统在空闲时关闭来减少泄漏功率[14]。

​		针对间歇性计算平台，探索新的处理器架构和备份策略仍有巨大的设计空间。例如，Ibex RISC-V处理器核心[15]是免费提供的，是现代超低功耗物联网计算应用的良好候选者，正如之前的研究所证明的那样，这些研究比较并证明了“零riscy”（Ibex核心的原名）适用于低功耗物联应用[16]。特别是，RISCV的优势之一是其分层和模块化ISA架构[17]，它提供了实现针对特定应用程序定制的最小指令集的灵活性。这在异构架构的情况下尤其有益，在异构架构中，可以选择性地激活不同复杂度的核心以适应最佳功率使用。同时，该处理器以前从未被间歇性应用程序使用过，因为它不包括集成NV存储器，因此在电源故障时会失去状态。研究人员没有必要的仿真环境来将NV内存和处理器备份策略引入这种处理器设计中。此外，在间歇性供电的情况下，很难测试、验证和基准测试不同的备份策略。现有技术使用数值模拟或ASIC实现来评估不同的备份策略和NVP。然而，数值模拟不足以将最终系统作为其他几个硬件组件的实际设计的一部分进行测试。另一方面，ASIC实现是昂贵的，并且在系统设计的早期阶段是不可用的。

​		**在这项工作中，我们介绍了基于中断的软件方法的不同处理器状态备份策略，这些策略不需要修改处理器的微体系结构。因此，这些策略可以很容易地扩展到各种不同的处理器。为了实现和评估我们不同的备份策略，我们使用了NV模拟框架，该框架专门为现成FPGA上的间歇性计算应用程序开发[18]。我们探讨了备份策略对Ibex RISC-V处理器上间歇程序执行性能的影响。更具体地说，本文的主要贡献如下。**

​		**1）系统仿真：我们提出了一种由瞬态处理架构组成的系统方法，以在瞬态功率下仿真具有不同备份策略的处理器。这是通过将通用NV存储器连接到处理器总线，并通过集成间歇性仿真器模块来实现的，该模块根据定义的能量配置文件提供电源故障信息。**

​		**2）设置最佳间歇策略的开发指南：根据对各种备份策略的结果所做的详细分析，我们制定了选择有用参数的指南，这些参数可能会随着时间的推移而变化和调整（对于给定的跟踪），这有助于回答何时备份的问题？这些指导方针有助于设计战略，并最大限度地提高未来广泛应用的效率。**

​		**3）间歇性RISC-V和超低功耗核心：我们介绍了开发和/或移植超低功耗处理器架构作为间歇性计算平台的基本构建块。本文中描述的硬件（中断生成器和间歇性仿真器）和软件（中断处理程序、保存和恢复策略算法）层的组合演示了如何使Ibex RISC-V内核适用于间歇性计算。**

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723144302133.png" alt="image-20230723144302133" style="zoom:50%;" />

​		图1给出了电源故障情况下备份/恢复操作期间程序执行流程的高级概述。蓝色图显示了可用的环境能量作为时间的函数。一旦超过定义的阈值（取决于特定策略），处理器就会在断电之前将其状态保存在NV存储器中。一旦再次有足够的能量可用，处理器恢复状态并恢复其正常操作。

​		本文的其余部分组织如下。第二节简要概述了当前与NVP和备份/恢复方法相关的研究和相关工作。我们在第三节中讨论了启用瞬态处理架构的组件，并给出了简要的实现细节。讨论了三种不同备份策略的结果，并在第四节中比较了它们的性能。然后，在第五节中，根据可用能量的不同时间分布，我们分析了表征策略的参数对性能的影响，并讨论了针对每种已识别的情况采取的可能方法，包括当参数随时间变化时的混合策略。最后，我们在第六节中提出我们的结论并讨论未来的工作。

### 2，相关工作

​		瞬态处理从CMOS处理器到NVP的发展，主要是提高备份/恢复操作的速度和能效，其根源在于存储器技术的进步（从闪存、FRAM、MRAM、RRAM、TFET和NCFET）[19]。虽然在早期的设计中，NV元件是一个中央片外存储器，需要顺序的字节级传输，但新兴的NVP具有嵌入式NV触发器（NVFF）和门，可以将其状态保持在寄存器级。由于NVFF[20]引起的大面积开销，仍然使用中央NV存储器的选择性备份策略，利用先进的NV存储器技术[10]，[21]-[23]。此外，已经提出了备份优化算法来在回写和直写策略之间切换，以减少备份故障引起的回滚，从而显著减少涌入电流[24]。

​		**在开发基于中央NV存储器/检查点的故障恢复系统时，要解决的主要设计问题是备份什么以及何时备份，以及NV系统的正确性[25]。**提出了使用启用FRAM的TI微控制器实现**中断驱动的检查点技术**，用于瞬态供电计算机（TPCs）[9]，[23]。它们不是跟踪使用中的活动寄存器，而是*在检查点期间备份整个通用寄存器文件，即使在动态频率缩放（DFS）下也是如此[26]*。编译时检查点触发实现，例如[27]–[31]和[32]，为程序员引入了最小的开销。例如，在[28]中，触发点被放置在每个环路展开之后，并且每个函数返回将输入电压（Vin）与阈值进行比较，并且如果Vin低于阈值则执行检查点。编译器和运行时系统实现实现了程序员的最小开销和备份策略的自适应节省。[27]中实施了另一种策略，该策略使用**计时器定期触发检查点**。在[29]中，liverange分析技术已被专门的编译器使用，该编译器自适应地仅备份在动态检查点系统中执行的所需易失性数据。**在ASIC实现的行为合成过程中插入检查点[33]**也被提出。此外，在具有循环的应用程序中，检查点的实现通常具有较高的开销，因为在循环执行期间需要备份大量数据。李等人[34]通过分析数据局部性和缩短循环中的数据寿命来减少检查点数据量。

​		先前已经进行了一些研究，以评估通过对几种处理器体系结构采用不同的备份策略所实现的正向进展的性能[11]。建议的策略，如**每个周期备份（BEC）、按需全备份（ODAB）和按需选择性备份（ODSB）**，适用于非管道处理器。使用“移位PC/易失性FlipFlop（SPC/VFF）”以及“NVFF”[11]，[35]研究了具有N级流水线架构的按顺序执行。当放置在每个流水线级之间的移位器缓冲器负责探测相关程序计数器（PC）以在电源故障（SPC/VFF）的情况下进行保存时，NVFF会自动保存每个级中的PC和寄存器堆，从而导致更多的时间和能量开销。针对无序（OoO）执行设置，提出了涉及备份更复杂硬件单元（如重新排序缓冲区（ROB）、指令队列（IQ）、映射表、分支历史缓冲区（BHT）和分支目标缓冲区（BTB））的策略[35]。

​		为了满足基于能量采集器的低功耗传感应用的基本使用情况，我们选择了具有2级有序处理的基于整数的RISC-V处理器内核（Ibex）。研究发现，**对于相对稳定的能源，ODSB是最节能的，而SPC/VFF在流水线有序处理器中表现良好[11]**。我们选择了类似的方法，有选择地将PC和最小寄存器文件保存到NV存储器中，以应对电源故障的通知事件。这些元数据是使用基于中断的软件方法从RISC-V核心中非侵入性地获取的，从而不会改变微体系结构，并有可能将相同的方法扩展到各种各样的处理器。

​		为了实现和评估我们不同的备份策略及其性能，我们通过集成RISC-V核心，利用了**NV模拟框架**，该框架专门为现成FPGA[18]、[36]上的间歇性计算应用程序开发。**该框架由一个间歇性模拟器模块（IEMU）和一个NV内存模块组成，前者可以对可能的电源故障进行知情预测，后者有助于模拟快速内置NV内存的行为。**架构和策略设计的选择在很大程度上受到输入功率及其稳定性的影响[11]。我们对高度波动的实际输入轨迹进行了详细研究[37]，并制定了选择有用参数（针对给定轨迹）的假设，这有助于回答何时备份的问题？这些观察结果可能有助于设计策略，并最大限度地提高未来广泛应用的效率。

### 3，瞬态NV处理体系结构

​		在本节中，我们介绍了瞬态处理架构，其中包括间歇性RISC-V核心设置，实现了不同备份策略的系统仿真，并帮助低功率传感应用程序（运行在能量采集器上）管理不稳定的功率条件，并在电力短缺后可靠地恢复其运行。瞬态处理的一般系统架构如图2所示，可分为**三个主要部分：1）瞬态处理核心；2） 存储器设置；3）间歇设置。处理核心通过将关键状态（PC、状态寄存器、寄存器文件等）保存到NV存储器NV_REG来支持瞬态操作。我们使用的处理器是Ibex（RV32IMC）RISC-V处理器核心[15]。间歇设置用于模拟实际工作硬件的电源可用性。该单元被设计为一个单独的模块，与核心一起实现，并通过中断线直接集成。最后，内存设置由NV_REG以及静态RAM（用于程序和数据的SRAM）组成，有助于程序执行和备份/恢复操作。存储器通过地址和数据总线直接与核心接口，并由适当的地址解码器激活。**整个系统在Vivado中用混合SystemVerilog/VVHDL语言进行了集成和实现，并对结果进行了仿真验证。在本节的其余部分中，我们将详细讨论这些部分。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723145427662.png" alt="image-20230723145427662" style="zoom: 80%;" />

1. 间歇性设置

​		对于指定的输入电压轨迹，通过三种不同的策略来评估系统的间歇性行为。电压轨迹对所有策略都是通用的，并且存储在IEMU内部的只读存储器（ROM）中。IEMU定期从跟踪存储器中读取值，并将状态信息传递给电路的其余部分，以模拟实际硬件的行为方式。ROM中总共有1569个值。每个值保留2500个时钟周期，即50毫秒，使总模拟时间达到75秒。IEMU通过将跟踪电压电平与一些阈值进行比较来工作。当电压下降到硬阈值（或复位阈值）以下时，IEMU激活reset信号，reset信号连接到除NV存储器NV_REG之外的所有硬件组件。重置信号会导致组件失去状态，从而有效地模拟掉电周期。IEMU的硬阈值在所有情况下都被设置为2800mV，因为晶体管逻辑在低于该电压电平时不会工作。其他阈值可以与不同的策略一起使用，如下所述。

​		1）**基于阈值的策略**：在基于阈值的策略中，在IEMU中选择第二阈值作为软阈值，停留在重置阈值之上。在任何给定的时间，IEMU将给出关于当前电压电平（来自ROM）和软阈值之间的比较状态的信息。*如果当前电压电平下降到软阈值以下，则产生中断。通过服务中断，内核可以在系统完全断电之前启动保存操作，将其内部状态备份到NV存储器*。

​		2）**周期性策略**：与基于阈值的策略不同，周期性策略不依赖于输入电压轨迹来对内核产生中断。相反，*使用外部专用计数器来周期性地生成对核心的中断*。计数器周期可以根据电压轨迹进行调整，以从该策略中获得最大性能。

​		3） **基于里程碑的策略**：基于里程碑的策略不依赖于NV保存操作对内核的外部中断。相反，中断服务例程被转换为一个正则函数，每当执行了Nf次典型的代码读取-计算-传输迭代时，就可以从`main（）`中调用该函数。最频繁的速率对应于在每次代码迭代时保存状态（里程碑=1）。

2. 内存设置

​		处理核心连接到内存映射系统，如图2所示。地址空间的初始64kB被保留给SRAM，SRAM是当处理器运行时存储程序和数据的主存储器区域。外围设备，如传感器和UART，通过内存映射端口连接到核心，因此通过直接访问分配给其配置和状态寄存器的地址空间来执行应用程序代码的读取和写入。64kB之后的接下来的16个存储器位置被保留用于NV存储器或NV_REG。为此，我们使用了专门为现成FPGA上的间歇性计算应用程序开发的NV模拟框架[18]。这种基于FPGA的框架被称为非易失性存储器模拟器（NORM），旨在模拟和验证任何利用快速NV存储器的间歇性计算系统的行为。NV_REG与SRAM和其他外围设备一样，直接连接到处理器地址和数据总线。地址解码器（如图2中的“1:2”所示）决定何时激活NV存储器。地址解码器基于核心请求的地址在SRAM和NV_REG之间切换（基于存储器掩码的地址解码）。连接到核心的所有内存单元都遵守内存事务的Ibex加载存储单元协议规范[38]。我们目前使用的16位宽NV存储器位置的初始12个字表示在表I中。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723152453242.png" alt="image-20230723152453242" style="zoom:50%;" />

​		第一个字存储脏位，脏位指示NV存储器是否包含保存的数据。这在确定是否需要执行恢复操作时非常有用。下一个位置称为PC，包含成功恢复后要恢复代码的指令的地址。接下来连续的八个位置存储通用寄存器的状态（a0–a7），然后是中断服务所需的CSR寄存器状态。专用于存储通用寄存器值的NV存储器的数量可以根据应用程序的要求（即，正确恢复程序执行需要多少寄存器）轻松扩展。在这里，为了简单起见，我们将说明限制为八个寄存器，因为我们用于评估的示例周期性传感器读取应用程序不需要保存更多数据。如前几节所述，保存到NV存储器由中断服务例程或主程序执行，而恢复操作由启动代码执行。

​		NV_REG读取/写入一个内存位置需要120μs。相反，SRAM在来自核心的数据读/写请求之间有100μs的延迟，直到成功完成确认。我们可以模拟NV_REG的延迟，根据规范取更大的值，在这种情况下，获得的结果也会相应变化。

3. 瞬态RISC-V（Ibex）核心

​		Ibex是流行的开源32位RISC-V CPU核心（2级流水线）之一，适用于低功耗嵌入式控制应用[15]。表II总结了本文中使用的Ibex岩芯版本的参数。核心在50kHz下工作，这类似于传感器的真实世界的低功率处理频率。用于保存处理器状态的功能包括快速中断、通用寄存器文件和某些CSR（在内核中断时启用中断并读取PC值）。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723151222349.png" alt="image-20230723151222349" style="zoom: 50%;" />

​		一般程序启动流程和相关的中断/NV保存逻辑如图3所示。为了完整起见，清单1-3中还显示了与各个阶段相对应的主要代码片段。核心运行一个样本C应用程序，该应用程序执行基本操作，例如从内存映射位置读取传感器值，计算其指数加权移动平均值，并将输出写入内存映射UART，以便通过无线电进行传输。这个程序，在图2中表示为program.vmem，在处理器启动时加载到内存中。应用程序的采样率设置为2Hz，这意味着从传感器读取每个值，执行计算并连续每0.5秒发送一次结果，并包括每次迭代前的延迟。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723151355589.png" alt="image-20230723151355589" style="zoom: 80%;" />

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723151437248.png" alt="image-20230723151437248" style="zoom: 80%;" />

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723151746225.png" alt="image-20230723151746225" style="zoom: 80%;" />

​		在输入`main（）`（如清单1所示，如图3中浅绿色阴影框所示）后，代码将值“0x00010000”写入控制寄存器`mie`（0x304，机器中断启用寄存器）以启用第一个快速中断信号（可用的15个信号中的一个），并通过将0x08写入`mstatus`（0x300，机器状态寄存器）来设置全局中断启用。这将使Ibex核心能够接收并服务于为周期性和基于阈值的策略给定的快速中断。在编译该程序后，我们观察到八个通用寄存器（a0–a7（x10–x17））在反汇编代码中用于读取/计算和写入结果。

​		因此，该应用程序还注册了一个专用的中断服务例程（如清单2所示，如图3中浅蓝色阴影框所示），标记为__attribute__（（中断）），其主要功能是写入脏位（指示NV区域的位具有有效数据），根据上述存储器布局，当前PC（“中断前PC”，其值在中断的情况下取自RISC-V处理器的mepc寄存器，否则在基于里程碑的策略的情况下存储函数返回地址）、a0–a7的内容以及NV区域上mie和mstatus控制寄存器的状态。

​		除了应用程序和中断的服务例程外，该程序还包括一个启动代码（如清单3所示，如图3中的一组浅橙色阴影框所示），每当内核通电时（无论是在开始时，还是在必须恢复执行时）都会执行。运行时启动代码crt0.S用于将编译后的C程序加载到内存中，因为我们没有使用任何操作系统或标准C库环境（在本例中为裸机C程序）。脚本定义并初始化中断向量表，定义重置处理程序，该处理程序清除所有寄存器，清除BSS部分，初始化堆栈部分，等等。

​		脚本的主要功能之一包括用于从NV存储器恢复处理器状态并从上次保存开始继续执行的逻辑。这是通过在复位后读取NV存储器地址的初始位置来完成的，以检查是否设置了脏位。在NV存储器中的所有保存值恢复到a0–a7以及控制和状态寄存器后，如果设置了位，则从先前保存的PC值继续执行。成功读取后，例程还重置脏位，以指示NV区域不包含任何有效数据（保存新状态后将再次设置该位）。如果未设置脏位，则在清除BSS部分后，程序从`main（）`开始执行，确保重置后程序流正常。

​		NV保存的模拟输出如图4所示。它示出了当来自ROM的数据（data_out）从2917变为2838时在`fast_irq_i`信号中产生的基于阈值的中断。这导致`mepc_q`捕获指令地址0x000001c4（内核中断时的PC值），然后是由`NVRE_en`、`NVRE_busy`信号表示的NV写入。NV写入后，内核继续正常执行。类似地，在图5中，当内核在电源故障后启动（reset_emulator_N）时，存储在NV存储器（NVRE_*）中的状态被恢复，并且内核从`instr_addr`中的0x000001c4继续执行。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723152121766.png" alt="image-20230723152121766" style="zoom:67%;" />

### 4，评估

​		我们已经建立并收集了所有三种策略的数据，并在本节中分析和介绍了结果。图6显示了我们用来获得结果的输入电压轨迹。该电压轨迹取自[37]，表示在距离RFID读取器约八英尺的范围内走动所收集的射频能量。在所有其他可用的跟踪[39]中，我们特别选择了此跟踪，因为它涵盖了感兴趣的保存-恢复处理器状态的所有可能组合，因此为我们提供了全面的结果。我们已经将硬阈值极限（RESET电压）选择为2800mV，低于该阈值，IEMU产生RESET信号，并且Ibex核心被重置。正如我们从电压轨迹中可以看到的，分别在650、550、700、1300、1250、1450、2100、1300、1150、100、700、2250、2550、900、550和50ms处总共有16个通电间隔，在此期间电压超过硬阈值并且系统通电。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723152334706.png" alt="image-20230723152334706" style="zoom:67%;" />

​		在本节的其余部分中，我们将分析系统在16个通电间隔中的每一个上的行为。我们根据表III中列出的方案对保存和恢复操作的结果进行颜色编码，从深灰色表示双重失败（保存和还原操作都不成功）变为白色表示双重成功。这提供了作为其操作参数的函数的策略性能的直观和清晰的可视化。此外，我们还讨论了该策略在CPU开销方面的影响。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723152356018.png" alt="image-20230723152356018" style="zoom:50%;" />

1. 基于阈值的策略

​		如图6所示，选择三个高于硬阈值（橙线）的软阈值来执行基于阈值的NV策略（分别为3000、3200和3400mv）。表IV给出了**基于阈值的策略在各种选择的软阈值的正确性方面的结果**。

​		由于在第一个间隔期间，NV存储器中没有预先存在的要恢复的保存值，因此我们通常假设结果为RF_SS。在除2900 mV阈值之外的所有情况下，计算的值都会在下一个引导周期中成功保存并连续恢复，直到间隔10。间隔10和16（分别具有通电持续时间100和50ms）与其他间隔相比具有更短的通电间隔，因此，在接收到中断之后没有提供足够的时间将结果保存到NV存储器。此外，在2900（间隔11和12）和3000（间隔11）的情况下，NV保存由于相同的原因而失败。特别注意，即使3400 mV阈值高于3200，它也无法在间隔15内保存，因为电压轨迹在回落到重置电平以下之前没有达到3400电平，因此没有发出保存操作（见图6）。**这意味着简单地选择更高的阈值并不一定能保证更好的性能，而是在很大程度上取决于所考虑的实际电压轨迹**。

​		从表IV中可以清楚地看出，软阈值3200 mV产生了最高的性能，正确率为87.5%（百分比是通过从总共16个间隔中取所有保存成功间隔来计算的），尽管3400 mV（性能=81.25%）是高于3200的阈值（所有保存成功情况都被视为成功）。3000 mV阈值的结果与3400（81.25%）相似。请注意，与其他阈值相比，将软阈值降低到硬阈值附近（2900的性能=56.25%）会产生次优结果。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723152947855.png" alt="image-20230723152947855" style="zoom:50%;" />

​		表V记录了不同软阈值下NV保存/恢复操作导致的实际CPU开销（根据使用的时钟周期数计算）。与其他阈值相比，3200mV阈值具有略高的开销（最后一列），因为RS_SS区域数量的增加为NV操作贡献了额外的周期（见表IV）。这清楚地表明了更高的性能（就正确性而言）和CPU开销之间的直接相关性。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723153038106.png" alt="image-20230723153038106" style="zoom:50%;" />

2. 周期策略

​		**周期性策略的性能取决于数据保存到NV存储器的周期与断电事件之间的时间间隔之间的关系，我们称之为通电间隔。**

​		图7显示了16个通电间隔中的每一个（横轴），其对应的持续时间（以秒为单位）（纵轴）。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723153218477.png" alt="image-20230723153218477" style="zoom: 50%;" />

​		通电间隔的平均持续时间等于1096.87ms，而最短间隔是第16个，持续时间等于50ms。就时钟周期而言，平均值对应于54844个时钟周期，而50ms等于2500个时钟周期。为了评估该策略，我们考虑最短间隔和平均间隔之间的周期。结果如表VI所示。在这种情况下，正如预期的那样，**周期越低，正确率越高**。特别是，平均周期仅实现50%的正确性，而选择最短的周期几乎可以保证提供正确的数据（100%的正确性）。显然，选择平均周期的问题在于，所有持续时间高于平均值的通电间隔（间隔1、2、3、10、11、14、15和16）都未能及时将数据保存到NV存储器，因为处理器在复位之前没有接收到来自计数器的中断。类似地，对于20000cc（400ms），间隔10和16的周期短于400ms，因此在复位之前不能保存它们的状态。因此，值得注意的是，通过组合有关通电间隔的信息并相应地调整周期性中断生成器，我们或多或少可以在正确性方面实现可预测的性能。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723153359175.png" alt="image-20230723153359175" style="zoom:50%;" />

​		就开销而言，我们从表VII（F列）中测量到，当计数器的周期减少时，总体CPU使用量急剧增加。平均通电间隔（54844cc）为我们提供了可忽略的低3.4%的开销，与最坏情况下最短通电间隔的67%（2500cc）相比。性能（正确性）与开销之间的权衡在这里清晰可见。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723153821861.png" alt="image-20230723153821861" style="zoom:50%;" />

3. 基于里程碑的战略

​		对于基于里程碑的策略，只有在计算数据之后才能保存数据。除了在每次计算迭代后保存外，我们还尝试在2或3次迭代后保存数据。结果见表八。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723153902665.png" alt="image-20230723153902665" style="zoom:50%;" />

​		第一列指示在将代码状态保存到NV区域之前执行代码的次数。另外，请注意，里程碑2和里程碑3的每个间隔单元中的数字表示间隔成功执行的代码迭代次数。在里程碑2的情况下，NV内存的脏位仅在偶数次迭代中设置。在所有其他情况下都会清除。类似地，对于里程碑3，当迭代达到3或3的倍数时，我们设置脏位以指示NV内存中的有效状态（即，在此之后保存到NV内存中的数据将是最新/正确状态）。否则，脏位无效。

​		由于保存到NV区域的PC值始终是里程碑函数调用的地址（在输出计算之后，在0.5 s延迟循环之前），在成功恢复之后，延迟循环始终首先执行。这就是为什么在间隔10（里程碑1和2）和16（里程碑1）中，我们没有足够的时间退出0.5 s延迟，计算/传输新值，然后将其保存到NV中。这也是里程碑1性能降低87.5%的原因，否则性能将接近100%。对于里程碑2和3，保存失败只是因为迭代次数不是该时间间隔内里程碑的倍数，如图所示。里程碑2的性能为68.75%，里程碑3的性能最差，为25%。

​		表IX显示了此策略的开销。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723154123844.png" alt="image-20230723154123844" style="zoom:50%;" />

​		在里程碑较高的情况下，每次迭代后清除脏位（如果迭代不是里程碑的倍数）的额外开销也会考虑在内。与前面的策略类似，总CPU利用率随着里程碑的降低而增加，并且非常频繁的保存操作对增加的贡献很大。

​		鉴于上一节概述的结果，我们现在继续分析不同参数对每个单独策略的性能的影响。**在选择NV保存策略时，需要考虑三个主要性能指标：1）恢复数据时所需的正确性级别；2） 电压跟踪的平均通电间隔时间；3）由于可以容忍的额外NV保存/恢复操作而引入的CPU开销。**

​		最佳策略和参数的选择显然取决于随时间变化的电压轨迹的形状以及处理器性能。在本节的其余部分中，我们考虑以“地形”的形式表示的不同形状，因为它们使人想起丘陵景观。图8示出了示例。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723154328581.png" alt="image-20230723154328581" style="zoom: 80%;" />

​		深蓝色区域位于重置阈值之下，而浅蓝色区域位于重置阈值之上。线GD表示定义的软阈值，该值将用作执行NV操作的参考电压。我们确定了几个参数，表征跟踪和处理器执行。

​		1） α-从上电事件到开始执行`main（）`函数所需的时间。
​		2） β-在超过“关闭”阈值之前执行`main（）`代码的可用时间。（从图8可以看出，点D是闭合阈值，因为在点D之后，轨迹继续保持在软阈值以下，并最终低于重置阈值。）
​		3） δ-软阈值（NV写入）和复位之间剩余的可用时间。
​		4） T<sub>STARTUP</sub>=重置后启动`main（）`代码所需的最短时间（在我们的例子中，这将是201 cc，所需的相应功率将是曲线BC下的面积）。
​		5） T<sub>SINGLE_EXEC</sub>=到达`main（）`代码后执行单个输出所需的最短时间，为72 cc。
​		6） T<sub>NV_SAVE</sub>=收到中断后NV写入所需的最短时间，为117 cc。

​		在我们的实现中，α= T<sub>STARTUP</sub>。下面，我们考虑每个绩效指标。

1. 正确性

​		为了在恢复已保存状态的同时实现接近100%的正确性，我们应该始终确保在断电之前执行的最后一个操作应该是NV保存。我们考虑以下两种情况。
​		1） 第一种情况<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723155344288.png" alt="image-20230723155344288" style="zoom:33%;" />这里，我们假设当电压轨迹低于第一个（软）阈值并且低于重置阈值之前，电压轨迹的形状总是为处理器提供足够的时间（δ)来执行SAVE操作。最佳策略取决于跟踪在两个阈值之间花费的持续时间。

​		A. 案例I.a

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723154936571.png" alt="image-20230723154936571" style="zoom: 80%;" />

​		在这种情况下，如图9所示，处理器有足够的时间来执行NV保存操作，但是在断电之前没有足够的时间来完成另一个传感器读取和计算周期。在超过阈值（点G）后保存，因此保存正确的状态。在这种情况下，与里程碑=1的基于里程碑的策略相比，基于阈值的策略是优选的。事实上，基于阈值的策略仅在必要时保存状态，并且总是在必要时保存状态，以最小的开销实现完全正确性。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723155038247.png" alt="image-20230723155038247" style="zoom:67%;" />

​		B.案例I.b

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723155118150.png" alt="image-20230723155118150" style="zoom: 80%;" />

​		在这种情况下，如图10所示，电压轨迹在下降到复位阈值之下之前长时间保持在两个阈值之间。在基于阈值的策略中，状态在越过第一个阈值时被保存。然后，处理器有时间执行几个传感器读取和计算周期，而不产生另一个中断开始。因此，基于阈值的策略导致丢失NV保存后计算的所有N值。采用基于里程碑的策略（为最佳情况结果设置里程碑=1）将更有效地保留所有值。使用周期策略（周期=tingle\u EXEC）与基于里程碑的策略同样有效，但由于中断生成计数器外围设备而增加了功率开销。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723155148071.png" alt="image-20230723155148071" style="zoom: 67%;" />

​		2） 第二种情况<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723155449142.png" alt="image-20230723155449142" style="zoom:33%;" />对于这种情况，我们假设第一阈值和复位电平之间的可用时间δ不足以保存处理器的状态。在这种情况下，基于阈值的策略显然是不可用的，因为它总是会导致不正确的恢复。因此，我们考虑从恢复程序执行到下一次断电β+δ之间的时间量，假设这对于至少一次执行和一次保存是足够的。

​		A.案例II.a<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723155627063.png" alt="image-20230723155627063" style="zoom:33%;" />图11中所示的极限情况是当存在用于一次应用迭代的执行和一次NV保存操作的精确时间时。然后，选择基于里程碑（对于最佳情况，里程碑=1）而不是周期性策略（如案例I.b中所述），将始终确保在每次代码迭代之后保存生成的即时输出。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723155735147.png" alt="image-20230723155735147" style="zoom:50%;" />

​		B.案例II.b<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723155652316.png" alt="image-20230723155652316" style="zoom:33%;" />在第二种情况下，通电和断电之间有足够的时间来执行几个迭代，如图12所示。由于与迭代相比，掉电不频繁，因此选择周期性策略（周期等于上电间隔)将更有效，无论是在减少CPU开销方面还是在减少NV节省的功耗方面，而不是基于里程碑的策略。这可以在表六中看到，有2500个时钟周期。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723155758696.png" alt="image-20230723155758696" style="zoom:50%;" />

2. 平均通电间隔

​		正如我们所看到的，通电间隔的长度影响每个策略的有效性。我们将影响总结如下。

​		1） 周期策略：选择一个等于平均通电时间间隔（表VI中的54 844个时钟周期）的周期可产生相应的平均性能。在我们的具体案例研究中，这将导致在正确性方面有50%的有效性（所有保存成功的案例都被认为是成功的）。较短的周期可提高性能，最高可达最小通电间隔（表VI中的2500个时钟周期），在正确性方面产生100%的有效性。同时，由于执行可能不必要的保存操作，开销增加。因此，通电间隔是用于根据要求调整中断生成计数器周期的基本度量。
​		2） 基于阈值的策略：通电间隔的持续时间与附加阈值上电压的特定变化基本不相关。因此，基于此度量很难预测基于阈值的策略的性能。然而，如果电压分布具有一定的规则性和/或周期性，则可以基于平均通电间隔来选择更多相关阈值，特别是如果考虑轨迹的斜率来推导前面讨论的定时参数。

​		3） 基于里程碑的策略：如果N是启动`main（）`代码（不考虑NV保存所需的时间）后可以成功执行的代码迭代次数（在电源间隔内），那么与电源间隔和Nf相关的等式可以编写如下：

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723160113032.png" alt="image-20230723160113032" style="zoom: 80%;" />

​		这里，N和Nf是变量，应该对其进行调整，使右侧几乎等于左侧。<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723160316778.png" alt="image-20230723160316778" style="zoom:50%;" />的值将是最终重置和上次成功保存操作之间剩余的时间。
​		通过设置Nf=1，可以很容易地获得（保证）正确性方面的最佳情况结果，但会导致最坏情况下的CPU开销。因此，为了获得最佳性能（在能量使用方面)，我们的目标应该是最大化Nf，满足条件<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723160417792.png" alt="image-20230723160417792" style="zoom:50%;" />

​		由于有许多通电间隔（具有不同的周期），我们可以找到一个适用于所有这些间隔的通用Nf（给定电压分布有点规则和/或周期性）。此通用Nf将确保在重置之前将所有地形的最新状态保存到NV中。其思想是，我们找到所有间隔<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723160544215.png" alt="image-20230723160544215" style="zoom:50%;" />中的最大公约数（GCD），并在每个GCD（小周期）时隙内调度作业（包括代码迭代和NV保存），如图13所示。这种循环调度与NV save一样，需要在每个次要周期内（细粒度程序）进行代码迭代，并且在每个次要周期中，代码迭代和NV save之间可能存在未使用的时间。通过将周期设置为小周期的周期策略（当中断到达时，在这种情况下可以进行抢占)，可以实现具有几乎相同结果的不太复杂的实现。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723160619619.png" alt="image-20230723160619619" style="zoom: 50%;" />

3. CPU开销

​		我们已经讨论了不同策略对CPU开销的影响。然而，当采用基于阈值的策略时，某些特定的电压轨迹形状可能会对性能产生较大的影响，因此应予以考虑。图14中示出了一个示例，其中电压电平在通电和断电之间（即，在β间隔内）多次跨越NV保存阈值。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723160826060.png" alt="image-20230723160826060" style="zoom:50%;" />

​		在这种情况下，基于阈值的策略引入了更高的CPU开销。最坏的情况是当交叉频率大约等于TNV\U SAVE时，因为<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723161128763.png" alt="image-20230723161128763" style="zoom:50%;" />将背靠背发生。即使跟踪满足案例I.a，我们也可以在频繁交叉的情况下使用基于周期/里程碑的策略。
​		类似地，在同一跟踪下，周期接近<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723161146460.png" alt="image-20230723161146460" style="zoom:50%;" />的周期性策略也会导致最大CPU开销，Nf=1的基于里程碑的策略也是如此。

4. 发展方针

​		当历史功率轨迹可用时，我们提供了一个根据上电脉冲设置最佳间歇策略的指南，如图15所示。对于一天中不同时段的不同δ，可以采用混合策略。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230723161051339.png" alt="image-20230723161051339" style="zoom:50%;" />

​		正如我们在第四节中所看到的，**对于相同的性能，基于阈值的策略的CPU开销要优于其他策略**。因此，在可行时，基于阈值的保存更为可取。案例I.a是理想情况，其中基于阈值的NV save在软阈值被跨越后立即完全适合功率跟踪。在I.b情况下，NVsave后剩余的额外时间可以通过自适应地降低软阈值（如果可能）来解决，以便在复位之前进一步推动NV save，或者在保存后的剩余时间采用循环调度方法（即，调度具有I.b情况特征的通电脉冲组，具有较小的−循环=GCD（δ−TNV\U save））。类似地，在情况II中，可以采用针对特定时间的阈值的自适应增加（如图15中的情况II.b所示），以获得用于NV save的足够δ。如果不可行，则里程碑/周期的基于计划的方法是最佳选择（即，计划具有案例II特性的通电脉冲组，小循环=GCD（β+δ））。
​		在这里，我们只考虑了电压跟踪特性和时钟周期所使用的核心进行我们的研究。作为替代方案，实际功耗应由内核和其他逻辑进行更精确的策略计算。基于编译器的运行时环境（或插件）可以集成到LLVM/GCC中，自动插入保存还原代码。这将确保最小的程序员开销，并捕获寄存器以便根据实时分析动态保存。

### 5，结论

​		由于能量收集电路的进步和处理功率需求的降低，许多物联网设备将以间歇方式无电池工作，使用从环境转换的唯一能量。间歇计算需要对现有处理器设计进行重大的微体系结构修改，以确保在自动断电的情况下计算进度。提出了一种在间歇计算域下对不同处理器结构进行仿真的系统方法。我们包装了Ibex RISC-V内核，以适合瞬态计算应用程序作为演示。此外，本文还提出了基于中断的软件方法的不同处理器状态备份策略，这些策略不需要修改现有处理器的微体系结构。我们将性能与不规则电源进行了比较，并以典型的物联网应用程序为基准，通过大量的测量和测试提供了全面的开发指南。
​		到目前为止，我们的备份策略考虑了电压跟踪特性和执行备份操作的时钟周期数。作为替代方案，可以考虑处理器和其他逻辑元件的实际功耗来实现更精确的策略。Ibex RV32IMC核心有许多特定的标准基准[40]，但这些基准面向性能评估（如CoreMark），不考虑可能的间歇性行为。因此，我们开发了一个特定的应用程序来验证我们的方法（如清单1中的数据采集循环所示），它是典型实现的代表。在未来的工作中，我们将使用来自不同能量采集器设置（即热电、压电、微光伏等）的真实轨迹，并分析最优策略如何根据不同的场景和基准变化。



