### 1 流水线分析及设计

​		经典五级流水线结构：

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230711090541591.png" alt="image-20230711090541591" style="zoom:50%;" />

​		在译码级，不仅需要读取寄存器中的值，还需要加入比较器等器件，导致延迟过长；

​		在执行级，由于ALU前端需要放置多路选择器，会导致执行级延迟较长。

​		文章设计的六级流水线结构，在经典的五级流水线的译码级和执行级之间添加了选择级，将译码级的比较器和多路选择器放在了选择级，可同时缩短译码级和执行级的延迟，进而提高处理器主频。为解决流水线加深所引起的分支指令造成的性能浪费问题，文章将分支判断提前放置在选择级。

​		文章的六级流水线：

- 取指：将指令从指令存储器中取出来
- 译码：将指令进行译码、产生控制信号，通过译码出来的寄存器索引从通用寄存器组中将操作数读出
- 选择：对即将进入ALU的数据进行选择，并计算分支跳转指令的目标地址
- 执行：使用ALU进行运算
- 访存：访问数据存储器，进行数据的读写
- 写回：将指令执行结果写回通用寄存器组

### 2 流水线数据冒险的处理

1. 数据冒险：指令执行需要之前指令的计算结果，而此结果还未计算出来

​		解决方式：定向前推

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230711093312814.png" alt="image-20230711093312814" style="zoom:50%;" />

​		如上图所示，第一条指令后所有的指令都使用了x1，按照正常流水线顺序，要等到第6周期add指令的结果才能写入寄存器，而后面三条指令分别在第3、4、5周期就需要x1中的结果，这就产生了数据冒险。

​		经过指令的时钟节拍分析，发现add指令结果在EX阶段，即第4个周期，就已经得到，故考虑将结果提前推出给后面的指令，从而解决数据冒险的问题。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230711094030622.png" alt="image-20230711094030622" style="zoom:50%;" />

2. 定向前推不能解决所有的数据冒险问题，加载指令所需的数据需要在前一条指令的MEM阶段之后才能使用

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230711094611460.png" alt="image-20230711094611460" style="zoom:50%;" />

​		解决方式：插入垂直气泡，将相应阶段阻塞到数据有效时再继续执行。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230711094722900.png" alt="image-20230711094722900" style="zoom:50%;" />

### 3 流水线控制冒险的处理

​		控制冒险：分支的流水线和其他指令改变程序计数器PC的值

​		分支跳转导致的流水线冲刷丢弃了很多正在执行的指令，若可以尽早确认分支是否跳转，可以减少分支跳转时被冲刷的指令数，确定分支跳转需要一个比较器，用于比较两个寄存器的值。

​		文章将比较器放置在DS阶段，比较后获取新的PC值，从而减少被冲刷指令数。

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230711095618428.png" alt="image-20230711095618428" style="zoom:50%;" />

<img src="C:\Users\张云鑫\AppData\Roaming\Typora\typora-user-images\image-20230711095636525.png" alt="image-20230711095636525" style="zoom:50%;" />