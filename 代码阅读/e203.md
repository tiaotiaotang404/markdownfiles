### 4.5 E203处理器的配置选项

配置文件config.v目录：

<img src="C:\WINDOWS\TEMP\WeChat Files\fc85b243eea66fac259cebe273c0009.jpg" alt="fc85b243eea66fac259cebe273c0009" style="zoom: 50%;" />

​		通过改变宏的定义，实现不同的配置，每个宏的含义在书的66页。

```
E203_CFG_PPI_BASE_REGION、E203_CFG_CLINT_BASE_REGION、E203_CFG_PLIC_BASE_REGION和E203_CFG_FIO_BASE_REGION：都是通过指定高位的区间来界定地址区间。例如，高位地址为31：28，可以得到高位地址区间共4位，可以得到共有2<sup>4</sup>=16个不同的地址区间，每个地址区间大小为2<sup>4</sup>=16字节，若基地址为0x1000_0000，则可得到第一个地址区间的起始地址为基地址=0x1000_0000，第二个地址区间的起始地址为0x1000_0010，依次类推得到最后的地址区间为0x1000_0000~0x1FFF_FFFF。
```

### 5.3 E203处理器核的RTL代码风格

#### 5.3.1 使用标准DFF模块例化生成寄存器

​		寄存器是数字同步电路中基本单元，最常见的方式是使用always块生成寄存器，而E203推荐采用模块化的标准DFF模块进行例化实现寄存器。

​		好处：

1. 便于全局替换寄存器类型
2. 便于在寄存器中全局插入延迟
3. 明确的load-enable使能信号可方便综合工具自动插入寄存器级别的门控时钟以降低功耗
4. 便于规避verilog语法中if-else不能传播不定态的问题

标准DFF模块源代码目录：

![23230d6eba35204a7dc57671c53091c](C:\Users\张云鑫\Desktop\23230d6eba35204a7dc57671c53091c.jpg)

​		其中D触发器处理lden信号的不定态的方式是使用断言进行捕捉

```verilog
//使用assertion捕捉lden信号的不定态
`ifndef FPGA_SOURCE//{
`ifndef DISABLE_SV_ASSERTION//{
//synopsys translate_off
sirv_gnrl_xchecker # (  //该模块内部是使用SystemVerilog编写的断言
  .DW(1)
) sirv_gnrl_xchecker(
  .i_dat(lden),
  .clk  (clk)
);
//synopsys translate_on
`endif//}
`endif//}
```

![947af1cf192b7da3e10a8fbdaa8d4c6](C:\WINDOWS\TEMP\WeChat Files\947af1cf192b7da3e10a8fbdaa8d4c6.jpg)

#### 5.3.2 使用assign语法替代if-else和case语法

​		verilog中的if-else和case语法存在的缺点：（1）不能传播不定态 （2）会产生优先级的选择电路而非并行选择电路，从而不利于优化时序和面积。

​		故推荐使用assign语句替代。

1. 传播不定态

​		举例如下：假设a为不定态（X），按照Verilog语法会将等效于a = 0，从而out输出为in2，没有将X传播出去

```verilog
if(a)
	out = in1;
else 
	out = in2;
```

​		使用功能等效的assign语法：

```verilog
assign out = a ? in1 :in2 ;
```

> 三目运算符：条件a为不定态X时，输出也为不定态X

2. 产生并行选择电路

​		if-else语法会被综合成优先级选择电路：

```verilog
if(sel1)
    out = in1[3:0];
else if (sel2)
    out = in2[3:0];
else if (sel3)
    out = in3[3:0];
else
    out = 4'b0;
```

​		若此处确实要生成一种优先级选择逻辑，推荐使用assign语法等效，规避X（不定态）传播的问题

```verilog
assign out = sel1 ? in1[3:0] :
    		 sel2 ? in2[3:0] :
    		 sel3 ? in3[3:0] :
    				4'b0;
```

​		若此处要生成一种并行选择逻辑，推荐使用assign语法明确的使用“与或”逻辑

```verilog
assign =  	({4{sel1}} & in1[3:0])
    	  | ({4{sel2}} & in2[3:0])
   		  | ({4{sel3}} & in3[3:0])
```

#### 5.3.3 其他注意事项

- 由于带reset信号的寄存器面积略大，时序稍微差一点，因此在数据通路上可以使用不带reset信号的寄存器，而只在控制通路上使用reset信号的寄存器
- 信号名避免使用拼音，使用英文缩写，代码即注释，从信号名中看出其功能
- Clock和Reset信号禁止用于任何其他的逻辑功能，这两个信号只能接入DFF，作为其时钟和复位信号

#### 5.5 E203处理器核的源代码

![ec42ddebd3b6d5ad21023ad04ce506c](C:\WINDOWS\TEMP\WeChat Files\ec42ddebd3b6d5ad21023ad04ce506c.jpg)

### 6.1 处理器流水线概述

#### 6.1.2 流水线和状态机的关系

- 流水线本质上可以理解为一种以面积换性能、以空间换时间的手段；
- 状态机本质上可以理解为一种以性能换面积、以时间换空间的手段；

​		**单从功能上来讲，处理器完全可以不使用流水线，而只使用状态机实现**，可以省掉流水线中的寄存器开销，还可以复用组合逻辑数据通路，因此面积开销比较小，但性能较差。

#### 6.1.3 流水线的深度

​		流水线级数越多，每一级流水线内容纳的硬件逻辑便越少，在两级寄存器（每一级流水线由寄存器组成）之间的硬件逻辑越少，则处理器能够达到更高的主频。这是流水线加深的正面意义。

​		由于每一级流水线都由寄存器组成，因此更多的流水线级数需要消耗更多的寄存器，占用更多的芯片面积。这是流水线加深的负面意义。

​		由于每一级流水线需要进行握手，流水线最后一级的反压信号可能会一直串扰到最前一级，造成严重的时序问题。这也是流水线加深的负面意义。

​		较深的处理器流水线还有一个问题，即跳转指令的分支预测问题，当预测错误时，流水线深度越深，会浪费更多的功耗和性能。这是流水线加深的另一个主要的负面意义。

#### 6.1.5 越来越浅的流水线

​		2012年发布的Cortex—M0+处理器核的流水线级数只有2，ARM宣传为世界上能效比最高的处理器核。

### 7.1 取指概述

#### 7.1.2 如何快速取指

​		为了能使处理器核以最快的速度取指，通常使用指令紧耦合存储器（ITCM）和指令缓存。

​		指令紧耦合存储器是指配置一段较小容量的存储器（通常使用SRAM）用于存储指令，且在物理上离处理器核很近而专属于处理器核，因此可以实现很小的访问延迟。优点是实现简单，保证实时性；缺点是只能用于存放容量大小有限的关键指令。

​		指令缓存将容量巨大的外部存储器空间动态映射到容量有限的指令缓存中，将访问指令存储器的平均延迟降到最低。

​		大多数极低功耗处理器应用于实时性较高的场景，因此通常使用延迟确定的ITCM。

#### 7.1.3 如何处理地址不对齐的指令

1. 普通指令的地址不对齐：

​		对于普通指令按顺序取指的情形，使用剩余缓冲区保存上次取指令后没有用完的位，供下次使用。

​		例如，从ITCM中取出一个32位的指令字，但只用其低16位，可能由以下两种原因造成：

- 只需要使用此次取出的32位中的低16位和上一次取出的高16位以组成一条32位的指令
- 这条指令的长度本身就是16位，只需取出低16位

​		此次没有用到的高16位可以暂存于缓冲区，待下一个时钟周期取出下一个32位的指令字之后，拼接出新的32位指令。

2. 分支跳转指令的地址不对齐：

​		由于剩余缓冲区只有在按顺序取指时，才能预存上次没有用完的指令字，不适用于分支跳转指令。常见的实现方式是使用多体化的SRAM进行指令的存储。如果跳转的地址与32位不对齐，且需要取值32位的指令，那么使用两个SRAM，指令字存在两个SRAM中，然后通过拼接获得指令。

#### 7.1.4 如何处理分支指令

1. 分支指令类型

   无条件跳转分支指令，是指一定会发生跳转的指令。

   - 无条件直接跳转/分支指令，这里的“直接”是指跳转的目标地址从指令编码的立即数可以直接计算。jal便属于无条件直接跳转指令
   - 无条件间接跳转/分支指令，这里的“间接”是指跳转的目标地址需要从寄存器索引的操作数中计算出来。jalr便属于无条件间接跳转指令。

   带条件跳转/分支指令，是指需要根据判断条件决定是否发生跳转的指令。

   - 带条件直接跳转/分支指令，在RISC-V中含有6条带条件分支指令
   - 带条件间接跳转/分支指令，RISC-V中没有此类型的指令。

   对于带条件跳转/分支指令，流水线在取指阶段无法得知该指令的条件是否成立，理论上只有在执行阶段完成之后才能解析出最终的跳转结果。为了提高性能，采用分支预测技术。

   分支预测需要解决两个方面的问题：

   - 预测分支指令是否真的需要跳转？简称为预测“方向”
   - 如果跳转，跳转的目标地址是什么？简称为预测“地址”

2. 预测方向

​		对方向的预测分为静态预测和动态预测两种。

​		最简单的静态预测的方法是总预测分支指令不会发生跳转，因此取指单元总是顺序取下一条指令，在执行阶段过后，若发现需要跳转，则会冲刷流水线，重新进行取指。

​		另一种常见的静态预测方法是BTFN预测，对于向后的跳转预测为跳，对于向前的跳转预测为不跳。向后的跳转是指跳转的目标地址比当前指令的PC值要小。

​		最简单的动态预测器为一位饱和计数器，每次分支指令执行之后便用此计数器记录上次的方向。其预测机制是下一次分支指令永远采用上一次记录的方向作为本次预测的方向。

​		两位饱和计数器是最常见的分支方向动态预测器，每次分支指令执行之后，其对应的状态机转换如图所示

<img src="C:\WINDOWS\TEMP\WeChat Files\131e156dc8cb450418e1a0192bdb4e7.jpg" alt="131e156dc8cb450418e1a0192bdb4e7" style="zoom: 50%;" />

​		当目前状态为强不需要跳转或弱不需要跳转时，预测该指令方向为不需要跳转；当目前状态为强需要跳转或弱需要跳转时，预测该指令方向为需要跳转。

​		两位饱和计数器对于预测一条分支指令很有效，但是处理器执行的指令流中存在着众多的不同分支指令，只用一个两位饱和计数器预测的效果会很不理想，每一条分支指令分配一个专属的两位饱和计数器硬件资源消耗太大。只能使用有限个两位饱和计数器组织成一个表格，然后对每条分支指令使用某种寻址方式来索引某个表项的两位饱和计数器。

​		目前一般使用各种不同的动态分支预测算法，通俗的讲就是通过采用不同的表格组织方式（控制表格的大小）和索引方式（控制别名重合问题），来提供更高的预测精准率。

​		最简单的方式是直接将有限个“两位饱和计数器”组织成一维的表格，该表格称为预测器表格，并直接使用PC的一部分进行索引。这种方式称为一级预测器，所谓“一级”是指其索引仅仅采用指令本身的PC值。

​		两级预测器也称为基于相关性的分支预测器。对于每条分支指令而言，将有限个两位饱和计数器组织成模式历史表（PHT）。使用该分支的跳转历史作为PHT的索引。

3. 预测地址

​		常见的技术：

​		分支目标缓冲区（BTB）技术是指使用容量有限的缓冲区保存最近执行过的分支指令的PC值，以及他们的跳转目标地址。是一种最简单快捷的地址预测算法，缺点之一是BTB容量不能太大，否则面积和时序都无法接受。另一个缺点是它对于间接跳转/分支指令的预测效果不理想。

​		返回地址栈（RAS）技术，是指使用容量有限的硬件栈来存储函数调用的返回地址。函数的调用和返回在程序中往往成对出现。因此可以在调用函数时将当前PC值加4或2，即将函数的返回地址压入栈中，这样就可以快速的为该函数返回的分支跳转指令预测目标地址。

#### 7.2.5 提供明确的静态分支预测依据

​		RISC-V架构文档明确规定，编译器生成的代码应当尽量优化，使向后跳转的分支指令比向前跳转的分支指令有更大的跳转概率，最大化的提高静态预测的准确率。

#### 7.2.6 提供明确的RAS依据

​		RISC-V架构文档明确规定，如果使用jal指令且目标寄存器索引值rd等于x1寄存器的值或者x5寄存器的值，需要入栈；如果使用jalr指令，按照使用的寄存器的值（rs1和rd）的不同，明确规定了相应的入栈或出栈行为。

### 7.3 E203处理器的取指实现

​		取指子系统主要包括取指令单元（IFU）和ITCM。

#### 7.3.1 IFU总体设计思路

<img src="C:\WINDOWS\TEMP\WeChat Files\1d1d22cc5ab01cc81bde9fea5b3b051.jpg" alt="1d1d22cc5ab01cc81bde9fea5b3b051" style="zoom:25%;" />

​		主要包括如下功能：

- 对取回的指令进行简单译码
- 简单的分支预测
- 生成取指的PC
- 根据PC地址访问ITCM或BIU（地址判断和ICB控制）

#### 7.3.2 简单译码

<img src="C:\WINDOWS\TEMP\WeChat Files\730d857a808adcefa61ea24d4b40765.jpg" alt="730d857a808adcefa61ea24d4b40765" style="zoom:25%;" />

​		只需要译出此指令是属于普通指令还是分支跳转指令、分支跳转指令的类型和细节。

​		此模块内部例化、调用了一个完整的译码模块，并将不相关的输入信号接零，输出信号悬空。

#### 7.3.3 简单BPU

<img src="C:\WINDOWS\TEMP\WeChat Files\3219ad6a8781fffceb50291afaccc4f.jpg" alt="3219ad6a8781fffceb50291afaccc4f" style="zoom:25%;" />

​		采用了最简单的静态分支预测。

#### 7.3.4 PC生成

![168e7c613c17c38b0d9233fd7c76948](C:\WINDOWS\TEMP\WeChat Files\168e7c613c17c38b0d9233fd7c76948.jpg)

#### 7.3.5 访问ITCM和BIU

1. 支持16位指令

![658868c93f031ae53a7fa5404d7f185](C:\WINDOWS\TEMP\WeChat Files\658868c93f031ae53a7fa5404d7f185.jpg)

2. 生成ICB接口访问ITCM和BIU的模块

![b9b837f1ac8931b10757ff36937e20f](C:\WINDOWS\TEMP\WeChat Files\b9b837f1ac8931b10757ff36937e20f.jpg)

#### 7.3.6 ITCM

​		E203采用ITCM作为指令存储器，由一块数据宽度为64位的单口SRAM组成。采用64位数据宽度可以获得更低的功耗开销。

#### 7.3.7 BIU

​		若取指令的地址不落在ITCM所在的区间，IFU会通过BIU访问外部存储器。

